{"ast":null,"code":"/* global define, Promise */\n(function (root, factory) {\n  'use strict';\n\n  if (typeof module === 'object' && module.exports && typeof require === 'function') {\n    // CommonJS\n    module.exports = factory();\n  } else if (typeof define === 'function' && typeof define.amd === 'object') {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else {\n    // Browser globals\n    root.Queue = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  /**\n   * @return {Object}\n   */\n  var LocalPromise = typeof Promise !== 'undefined' ? Promise : function () {\n    return {\n      then: function () {\n        throw new Error('Queue.configure() before use Queue');\n      }\n    };\n  };\n  var noop = function () {};\n\n  /**\n   * @param {*} value\n   * @returns {LocalPromise}\n   */\n  var resolveWith = function (value) {\n    if (value && typeof value.then === 'function') {\n      return value;\n    }\n    return new LocalPromise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  /**\n   * It limits concurrently executed promises\n   *\n   * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises\n   * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises\n   * @constructor\n   *\n   * @example\n   *\n   * var queue = new Queue(1);\n   *\n   * queue.add(function () {\n   *     // resolve of this promise will resume next request\n   *     return downloadTarballFromGithub(url, file);\n   * })\n   * .then(function (file) {\n   *     doStuffWith(file);\n   * });\n   *\n   * queue.add(function () {\n   *     return downloadTarballFromGithub(url, file);\n   * })\n   * // This request will be paused\n   * .then(function (file) {\n   *     doStuffWith(file);\n   * });\n   */\n  function Queue(maxPendingPromises, maxQueuedPromises, options) {\n    this.options = options = options || {};\n    this.pendingPromises = 0;\n    this.maxPendingPromises = typeof maxPendingPromises !== 'undefined' ? maxPendingPromises : Infinity;\n    this.maxQueuedPromises = typeof maxQueuedPromises !== 'undefined' ? maxQueuedPromises : Infinity;\n    this.queue = [];\n  }\n\n  /**\n   * Defines promise promiseFactory\n   * @param {Function} GlobalPromise\n   */\n  Queue.configure = function (GlobalPromise) {\n    LocalPromise = GlobalPromise;\n  };\n\n  /**\n   * @param {Function} promiseGenerator\n   * @return {LocalPromise}\n   */\n  Queue.prototype.add = function (promiseGenerator) {\n    var self = this;\n    return new LocalPromise(function (resolve, reject, notify) {\n      // Do not queue to much promises\n      if (self.queue.length >= self.maxQueuedPromises) {\n        reject(new Error('Queue limit reached'));\n        return;\n      }\n\n      // Add to queue\n      self.queue.push({\n        promiseGenerator: promiseGenerator,\n        resolve: resolve,\n        reject: reject,\n        notify: notify || noop\n      });\n      self._dequeue();\n    });\n  };\n\n  /**\n   * Number of simultaneously running promises (which are resolving)\n   *\n   * @return {number}\n   */\n  Queue.prototype.getPendingLength = function () {\n    return this.pendingPromises;\n  };\n\n  /**\n   * Number of queued promises (which are waiting)\n   *\n   * @return {number}\n   */\n  Queue.prototype.getQueueLength = function () {\n    return this.queue.length;\n  };\n\n  /**\n   * @returns {boolean} true if first item removed from queue\n   * @private\n   */\n  Queue.prototype._dequeue = function () {\n    var self = this;\n    if (this.pendingPromises >= this.maxPendingPromises) {\n      return false;\n    }\n\n    // Remove from queue\n    var item = this.queue.shift();\n    if (!item) {\n      if (this.options.onEmpty) {\n        this.options.onEmpty();\n      }\n      return false;\n    }\n    try {\n      this.pendingPromises++;\n      resolveWith(item.promiseGenerator())\n      // Forward all stuff\n      .then(function (value) {\n        // It is not pending now\n        self.pendingPromises--;\n        // It should pass values\n        item.resolve(value);\n        self._dequeue();\n      }, function (err) {\n        // It is not pending now\n        self.pendingPromises--;\n        // It should not mask errors\n        item.reject(err);\n        self._dequeue();\n      }, function (message) {\n        // It should pass notifications\n        item.notify(message);\n      });\n    } catch (err) {\n      self.pendingPromises--;\n      item.reject(err);\n      self._dequeue();\n    }\n    return true;\n  };\n  return Queue;\n});","map":{"version":3,"names":["root","factory","module","exports","require","define","amd","Queue","LocalPromise","Promise","then","Error","noop","resolveWith","value","resolve","maxPendingPromises","maxQueuedPromises","options","pendingPromises","Infinity","queue","configure","GlobalPromise","prototype","add","promiseGenerator","self","reject","notify","length","push","_dequeue","getPendingLength","getQueueLength","item","shift","onEmpty","err","message"],"sources":["/media/giada/OS/Users/Asus/OneDrive - Università degli Studi di Catania/_Università/Web Programming/Progetto/progetto/client/node_modules/promise-queue/lib/index.js"],"sourcesContent":["/* global define, Promise */\n(function (root, factory) {\n    'use strict';\n    if (typeof module === 'object' && module.exports && typeof require === 'function') {\n        // CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && typeof define.amd === 'object') {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else {\n        // Browser globals\n        root.Queue = factory();\n    }\n})\n(this, function () {\n    'use strict';\n\n    /**\n     * @return {Object}\n     */\n    var LocalPromise = typeof Promise !== 'undefined' ? Promise : function () {\n        return {\n            then: function () {\n                throw new Error('Queue.configure() before use Queue');\n            }\n        };\n    };\n\n    var noop = function () {};\n\n    /**\n     * @param {*} value\n     * @returns {LocalPromise}\n     */\n    var resolveWith = function (value) {\n        if (value && typeof value.then === 'function') {\n            return value;\n        }\n\n        return new LocalPromise(function (resolve) {\n            resolve(value);\n        });\n    };\n\n    /**\n     * It limits concurrently executed promises\n     *\n     * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises\n     * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises\n     * @constructor\n     *\n     * @example\n     *\n     * var queue = new Queue(1);\n     *\n     * queue.add(function () {\n     *     // resolve of this promise will resume next request\n     *     return downloadTarballFromGithub(url, file);\n     * })\n     * .then(function (file) {\n     *     doStuffWith(file);\n     * });\n     *\n     * queue.add(function () {\n     *     return downloadTarballFromGithub(url, file);\n     * })\n     * // This request will be paused\n     * .then(function (file) {\n     *     doStuffWith(file);\n     * });\n     */\n    function Queue(maxPendingPromises, maxQueuedPromises, options) {\n        this.options = options = options || {};\n        this.pendingPromises = 0;\n        this.maxPendingPromises = typeof maxPendingPromises !== 'undefined' ? maxPendingPromises : Infinity;\n        this.maxQueuedPromises = typeof maxQueuedPromises !== 'undefined' ? maxQueuedPromises : Infinity;\n        this.queue = [];\n    }\n\n    /**\n     * Defines promise promiseFactory\n     * @param {Function} GlobalPromise\n     */\n    Queue.configure = function (GlobalPromise) {\n        LocalPromise = GlobalPromise;\n    };\n\n    /**\n     * @param {Function} promiseGenerator\n     * @return {LocalPromise}\n     */\n    Queue.prototype.add = function (promiseGenerator) {\n        var self = this;\n        return new LocalPromise(function (resolve, reject, notify) {\n            // Do not queue to much promises\n            if (self.queue.length >= self.maxQueuedPromises) {\n                reject(new Error('Queue limit reached'));\n                return;\n            }\n\n            // Add to queue\n            self.queue.push({\n                promiseGenerator: promiseGenerator,\n                resolve: resolve,\n                reject: reject,\n                notify: notify || noop\n            });\n\n            self._dequeue();\n        });\n    };\n\n    /**\n     * Number of simultaneously running promises (which are resolving)\n     *\n     * @return {number}\n     */\n    Queue.prototype.getPendingLength = function () {\n        return this.pendingPromises;\n    };\n\n    /**\n     * Number of queued promises (which are waiting)\n     *\n     * @return {number}\n     */\n    Queue.prototype.getQueueLength = function () {\n        return this.queue.length;\n    };\n\n    /**\n     * @returns {boolean} true if first item removed from queue\n     * @private\n     */\n    Queue.prototype._dequeue = function () {\n        var self = this;\n        if (this.pendingPromises >= this.maxPendingPromises) {\n            return false;\n        }\n\n        // Remove from queue\n        var item = this.queue.shift();\n        if (!item) {\n            if (this.options.onEmpty) {\n                this.options.onEmpty();\n            }\n            return false;\n        }\n\n        try {\n            this.pendingPromises++;\n\n            resolveWith(item.promiseGenerator())\n            // Forward all stuff\n                .then(function (value) {\n                    // It is not pending now\n                    self.pendingPromises--;\n                    // It should pass values\n                    item.resolve(value);\n                    self._dequeue();\n                }, function (err) {\n                    // It is not pending now\n                    self.pendingPromises--;\n                    // It should not mask errors\n                    item.reject(err);\n                    self._dequeue();\n                }, function (message) {\n                    // It should pass notifications\n                    item.notify(message);\n                });\n        } catch (err) {\n            self.pendingPromises--;\n            item.reject(err);\n            self._dequeue();\n\n        }\n\n        return true;\n    };\n\n    return Queue;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}